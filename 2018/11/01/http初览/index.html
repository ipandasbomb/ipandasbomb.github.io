<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="风起在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="风起" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        爬虫杂记｜风起&#39;s blog
        
    </title>

    <link rel="canonical" href="http://ipandasbomb.github.io/2018/11/01/http初览/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    风起
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="source\img\post-default.jpg">


<style>
    
    header.intro-header {
        background-image: url('source\img\post-default.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>爬虫杂记</h1>
                    
                    <span class="meta">
                         作者 风起
                        <span>
                          日期 2018-11-01
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            爬虫杂记
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>爬虫杂记</p>
<h3 id="User-agent"><a href="#User-agent" class="headerlink" title="User-agent"></a>User-agent</h3><p>意思是用户代理。用户代理是一种对数据打包、创造分组头，以及编址、传递消息的部件。用户代理是指浏览器,它的信息包括硬件平台、系统软件、应用软件和用户个人偏好.用户代理，它还包括搜索引擎。</p>
<p>来自 <a href="https://zhidao.baidu.com/question/179058918.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/179058918.html</a> </p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><pre><code>客户端指定自己想访问的http服务器的域名/IP 地址和端口号。
今天同事问了一个问题引发了我对http头中host字段的详细思考，总结了以下5条。
1.host字段可以是域名，也可以是ip地址。host字段域名/ip后可以跟端口号，如Host: www.6san.com:8080
2.host可以由程序自定义，某些程序为了防止运营商或防火墙拦截会定义虚假host
3.http1.1中host字段可以是空值，http1.0中可以缺失host字段
4.http响应头中不包含host字段，所以wireshark中http.host过滤到的都是请求包
5.因为http头中的host字段可以由程序自定义，所以host字段的值就会有很多特殊情况，如包含多个’/&apos;字符的HOST头信息，结尾含有”.”等
http头中可以没有host字段吗？
在http 1.1中不能缺失host字段,如果缺失, 服务器返回400 bad request，http1.1中不能缺失host字段，但host字段可以是空值。
在http 1.0中可以缺失host字段。
RFC 2616中关于host字段的说明如下：
A client MUST include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value. An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy. All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.
</code></pre><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><pre><code>简而言之，HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。

来自 [Referer](https://baike.baidu.com/item/HTTP_REFERER/5358396?fr=aladdin)
</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。

Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。

有关使用 Session 对象的详细信息，请参阅“ASP 应用程序”部分的“管理会话”。注意 会话状态仅在支持 cookie 的浏览器中保留。

Session直接翻译成中文比较困难，一般都译成时域。在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。以及如果需要的话，可能还有一定的操作空间。

具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到关闭浏览器所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，Session实际上是一个特定的时间概念。

需要注意的是，一个Session的概念需要包括特定的客户端，特定的服务器端以及不中断的操作时间。
A用户和C服务器建立连接时所处的Session同B用户和C服务器建立连接时所处的Session是两个不同的Session。
session的工作原理
（1）当一个session第一次被启用时，一个唯一的标识被存储于本地的cookie中。
（2）首先使用session_start()函数，PHP从session仓库中加载已经存储的session变量。
（3）当执行PHP脚本时，通过使用session_register()函数注册session变量。
（4）当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.save_path指定，下次浏览网页时可以加载使用。
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>存储需要在整个用户会话过程中保持其状态的信息，例如登录信息或用户浏览 Web应用程序时需要的其它信息。
存储只需要在页重新加载过程中或按功能分组的一组页之间保持其状态的对象。
Session 的作用就是它在 Web服务器上保持用户的状态信息供在任何时间从任何设备上的页面进行访问。因为浏览器不需要存储任何这种信息，所以可以使用任何浏览器，即使是像 Pad 或手机这样的浏览器设备。

来自 &lt;https://baike.baidu.com/item/session/479100?fr=aladdin&gt; 

高级用法
http://docs.python-requests.org/zh_CN/latest/user/advanced.html
</code></pre><h3 id="Cookie详解"><a href="#Cookie详解" class="headerlink" title="Cookie详解"></a>Cookie详解</h3><pre><code>没怎么坐过客户端相关的工作，所以写爬虫的时候，很多概念都很模糊，学习起来很困难。现在想攻坚一下，所以找了一下cookies相关的内容。

HTTP cookies，通常又称作&quot;cookies&quot;
 早期Web开发面临的最大问题之一是如何管理状态。服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个token，并且在下一次请求中将这个token返回（至服务器）。这就需要在form中插入一个包含token的隐藏表单域，或着在URL的qurey字符串中传递该token。这两种办法都强调手工操作并且极易出错。

cookies工作原理的基本信息在RFC2109中被规范化

cookie是什么？
一个cookie就是存储在用户主机浏览器中的一小段文本文件。
Cookies是纯文本形式，它们不包含任何可执行代码。
一个Web页面或服务器告之浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web服务器之后可以利用这些信息来标识用户。

通过HTTP的Set-Cookie消息头，Web服务器可以指定存储一个cookie。

Set-Cookie消息的格式如下面的字符串（中括号中的部分都是可选的）

Set-Cookie:value [ ;expires=date][ ;domain=domain][ ;path=path][ ;secure]

value部分，通常是一个name=value格式的字符串。事实上有很多浏览器用自己的格式，有细微的不同。
当一个cookie存在，并且可选条件允许的话，该cookie的值会在接下来的每个请求中被发送至服务器。

cookie的值被存储在名为Cookie的HTTP消息头中，并且只包含了cookie的值，其它的选项全部被去除。
可选项只是存在于浏览器端，并不需要发给服务端。
例如： Cookie : value

如果在指定的请求中有多个cookies，那么它们会被分号和空格分开，例如：
Cookie:value1 ; value2 ; name1=value1

有效期选项（The expires  option）
指定了cookie过期的时间，过期后可能会被浏览器删掉。
格式为Wdy,DD-Mon--YYYY HH:MM:SS GMT，例如：
Set-Cookie:name=Nicholas;expires=Sat, 02 May 2009 23:38:25 GMT
在没有expires选项时，cookie的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话cookie只存在于浏览器保持打开的状态之下。
</code></pre><h4 id="domain选项（The-domain-option）"><a href="#domain选项（The-domain-option）" class="headerlink" title="domain选项（The domain option）"></a>domain选项（The domain option）</h4><pre><code>指示cookie将要发送到哪个域或那些域中。默认情况下，domain会被设置为创建该cookie的页面所在的域名。
domain选项被用来扩展cookie值所要发送域的数量。例如:
Set-Cookie:name=Nicholas;domain=www.baidu.com
很多时候大网站存在二级域名，例如fanyi.baidu.com。cookies可能只发给对应的二级域名。
</code></pre><h4 id="Path选项（The-path-option）"><a href="#Path选项（The-path-option）" class="headerlink" title="Path选项（The path option）"></a>Path选项（The path option）</h4><pre><code>在请求相匹配的路径的时候，才会发送cookie
例如：
Set-Cookie:name=Nicholas;path=/blog
在这个例子中，path选项值会与/blog,/blogrool等等相匹配；任何以/blog开头的选项都是合法的。
</code></pre><h4 id="secure选项（The-secure-option）"><a href="#secure选项（The-secure-option）" class="headerlink" title="secure选项（The secure option）"></a>secure选项（The secure option）</h4><pre><code>该选项只是一个标记并且没有其它的值。只有当请求是通过SSL和HTTPS创建时，才会发送。
这种cookie的内容意指具有很高的价值并且可能潜在的被破解以纯文本形式传输。例如
Set-Cookie:name=Nicholas;secure
现实中，机密且敏感的信息绝不应该在cookies中存储或传输，因为cookies的整个机制都是原本不安全的。
默认情况下，在HTTPS链接上传输的cookies都会被自动添加上secure选项。

cookie的维护和生命周期（cookie maintenance and lifecycle）
任意数量的选项都可以在单一的cookie中指定，并且这些选项可以以任何顺序存在，例如
Set-Cookie:name=Nicholas; domain=nczonline.net; path=/blog
这个cooke有四个标识符：cookie的name，domain，path，secure标记。
要想在将来改变这个cookie的值，需要发送另一个具有相同cookie name,domain,path的Set-Cookie消息头。
例如：
Set-Cooke:name=Greg; domain=nczonline.net; path=/blog
这将以一个新的值来覆盖原来cookie的值。
然而，仅仅只是改变这些选项的某一个也会创建一个完全不同的cookie，
例如：
Set-Cookie:name=Nicholas; domain=nczonline.net; path=/
在返回这个消息头后，会存在两个同时拥有“name”的不同的cookie。
如果你访问在www.nczonline.NET/blog下的一个页面，以下的消息头将被包含进来：
Cookie：name=Greg;name=Nicholas
在这个消息头中存在了两个名为“name”的cookie，path值越详细则cookie越靠前。domain-path越详细则cookie字符串越靠前。假设我在ww.nczonline.Net/blog下并且发送了另一个cookie，其设置如下：
Set-Cookie:name=Mike
那么返回的消息头现在则变为：
Cookie：name=Mike;name=Greg;name=Nicholas
由于包含“Mike”的cookie使用了域名（www.nczonline.net）作为其domain值并且以全路径（/blog）作为其path值，则它较其它两个cookie更加详细。
</code></pre><h4 id="使用失效日期（using-expiration-dates）"><a href="#使用失效日期（using-expiration-dates）" class="headerlink" title="使用失效日期（using expiration dates）"></a>使用失效日期（using expiration dates）</h4><pre><code>当cookie创建时包含了失效日期，这个失效日期则关联了以name-domain-path-secure为标识的cookie。
要改变一个cookie的失效日期，必须指定同样的组合。当改变一个cookie的值时，你不必每次都设置失效日期，因为它不是cookie标识信息的组成部分。
例如：
Set-Cookie:name=Mike;expires=Sat,03 May 2025 17:44:22 GMT
现在已经设置了cookie的失效日期，所以下次我想要改变cookie的值时，我只需要使用它的名字：
Set-Cookie:name=Matt
在cookie上的失效日期并没有改变，因为cookie的标识符是相同的。实际上，只有你手工的改变cookie的失效日期，否则其失效日期不会改变。这意味着在同一个会话中，一个会话cookie可以变成一个持久化cookie（一个可以在多个会话中存在的），反之则不可。为了要将一个持久化cookie变为一个会话cookie，你必须删除这个持久化cookie，这只要设置它的失效日期为过去某个时间之后再创建一个同名的会话cookie就可以实现。
需要记得的是失效日期是以浏览器运行的电脑上的系统时间为基准进行核实的。没有任何办法来来验证这个系统时间是否和服务器的时间同步，所以当服务器时间和浏览器所处系统时间存在差异时这样的设置会出现错误。

cookie自动删除（automatic cookie removal）
cookie会被浏览器自动删除，通常存在以下几种原因：
会话cooke(Session cookie)在会话结束时（浏览器关闭）会被删除
持久化cookie（Persistent cookie）在到达失效日期时会被删除
如果浏览器中的cookie限制到达，那么cookies会被删除以为新建cookies创建空间。
对于任何这些自动删除来说，Cookie管理显得十分重要，因为这些删除都是无意识的。

Cookie限制条件（Cookie restrictions）
在cookies上存在了诸多限制条件，来阻止cookie滥用并保护浏览器和服务器免受一些负面影响。
有两种cookies的限制条件：cookies的属性和cookies的总大小。
原始的规范中限定每个域名下不超过20个cookies，早期的浏览器都遵循该规范，并且在IE7中有个更近一步的提升。
在微软的一次更新中，他们在IE7中增加cookies的限制到50个，与此同时Opera限定cookies个数为30.Safari和Chrome对与每个域名下的cookies个数没有限制。
发向服务器的所有cookies的最大数量（空间）仍旧维持原始规范中所指出的：4KB。
所有超出该限制的cookies都会被截掉并且不会发送至服务器。
</code></pre><h3 id="Subcookies"><a href="#Subcookies" class="headerlink" title="Subcookies"></a>Subcookies</h3><pre><code>鉴于cookie的数量限制，开发者提出的subcookies的观点来增加cookies的存储量。
Subcookies是一些存储在一个cookie的value中的一些name-value对，并且通常与以下格式类似：
name=a=b&amp;c=d&amp;e=f&amp;g=h
这种方式允许在单个cookie中保存多个name-value对，而不会超过浏览器cookie的数量限制。
通过这种方式创建cookies的负面影响是，需要自定义解析方式来提取这些值，相比较而言cookies的格式会更为简单。服务器端框架已开始支持subcookies的存储。

来自 &lt;http://blog.csdn.net/u012175089/article/details/70054806&gt; 
</code></pre><h3 id="Status-Code"><a href="#Status-Code" class="headerlink" title="Status Code"></a>Status Code</h3><p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><pre><code>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
</code></pre><h4 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h4><pre><code>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。
</code></pre><h4 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h4><pre><code>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。
只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。
</code></pre><h4 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h4><pre><code>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行成功.
这一类型的状态码，代表请求已成功被服务器接收、理解、并接受[1]  。
</code></pre><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><pre><code>请求已成功，请求所希望的响应头或数据体将随此响应返回。
</code></pre><h4 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h4><pre><code>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &apos;202 Accepted&apos;。
</code></pre><h4 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h4><pre><code>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。
</code></pre><h4 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h4><pre><code>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。
</code></pre><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><pre><code>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。
如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。
由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
</code></pre><h4 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h4><pre><code>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
</code></pre><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><pre><code>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。
该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
响应必须包含如下的头部域：
Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。
Date
ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。
Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。
假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。
假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。
</code></pre><h4 id="207-Multi-Status"><a href="#207-Multi-Status" class="headerlink" title="207 Multi-Status"></a>207 Multi-Status</h4><pre><code>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。
</code></pre><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><pre><code>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。
当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。
</code></pre><h4 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h4><pre><code>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。
除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。
如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。
</code></pre><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><pre><code>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。
如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。
</code></pre><h4 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 Move temporarily"></a>302 Move temporarily</h4><pre><code>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
上文有提及。
如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。
</code></pre><h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><pre><code>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。
注意：许多 HTTP/1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。
</code></pre><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><pre><code>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
该响应必须包含以下的头信息：
Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。
ETag 和/或 Content-Location，假如同样的请求本应返回200响应。
Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。
假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。
假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。
假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。
</code></pre><h4 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h4><pre><code>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。
注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。
</code></pre><h4 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h4><pre><code>在最新版的规范中，306状态码已经不再被使用。
</code></pre><h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><pre><code>请求的资源临时从不同的URI 响应请求。
新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。
如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
</code></pre><h4 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h4><pre><code>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。
如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。
</code></pre><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><pre><code>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。
</code></pre><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><pre><code>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。
</code></pre><h4 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h4><pre><code>该状态码是为了将来可能的需求而预留的。
</code></pre><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><pre><code>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。
</code></pre><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><pre><code>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。
</code></pre><h4 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h4><pre><code>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。
鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。
</code></pre><h4 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h4><pre><code>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。
</code></pre><h4 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h4><pre><code>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。
</code></pre><h4 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h4><pre><code>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
</code></pre><h4 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h4><pre><code>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。
冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。
</code></pre><h4 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h4><pre><code>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。
410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为&apos;410 Gone&apos;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。
</code></pre><h4 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h4><pre><code>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。
</code></pre><h4 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h4><pre><code>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。
</code></pre><h4 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h4><pre><code>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。
如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。
</code></pre><h4 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h4><pre><code>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：
本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。
重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。
客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。
</code></pre><h4 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h4><pre><code>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。
</code></pre><h4 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h4><pre><code>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。
假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。
</code></pre><h4 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h4><pre><code>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。
</code></pre><h4 id="421-too-many-connections"><a href="#421-too-many-connections" class="headerlink" title="421 too many connections"></a>421 too many connections</h4><pre><code>There are too many connections from your internet address
从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。
</code></pre><h4 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h4><pre><code>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）
</code></pre><h4 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h4><pre><code>当前资源被锁定。（RFC 4918 WebDAV）
</code></pre><h4 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h4><pre><code>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）
</code></pre><h4 id="425-Unordered-Collection"><a href="#425-Unordered-Collection" class="headerlink" title="425 Unordered Collection"></a>425 Unordered Collection</h4><pre><code>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。
</code></pre><h4 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h4><pre><code>客户端应当切换到TLS/1.0。（RFC 2817）
</code></pre><h4 id="449-Retry-With"><a href="#449-Retry-With" class="headerlink" title="449 Retry With"></a>449 Retry With</h4><pre><code>由微软扩展，代表请求应当在执行完适当的操作后进行重试。
</code></pre><h4 id="451Unavailable-For-Legal-Reasons"><a href="#451Unavailable-For-Legal-Reasons" class="headerlink" title="451Unavailable For Legal Reasons"></a>451Unavailable For Legal Reasons</h4><pre><code>该请求因法律原因不可用。（RFC 7725）
</code></pre><h3 id="服务器错误（5、6字头）"><a href="#服务器错误（5、6字头）" class="headerlink" title="服务器错误（5、6字头）"></a>服务器错误（5、6字头）</h3><pre><code>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。
这些状态码适用于任何响应方法。
</code></pre><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><pre><code>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
</code></pre><h4 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h4><pre><code>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。
</code></pre><h4 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h4><pre><code>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
</code></pre><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><pre><code>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。
注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。
</code></pre><h4 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h4><pre><code>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
注意：某些代理服务器在DNS查询超时时会返回400或者500错误
</code></pre><h4 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h4><pre><code>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。
</code></pre><h4 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h4><pre><code>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。
</code></pre><h4 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h4><pre><code>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)
</code></pre><h4 id="509-Bandwidth-Limit-Exceeded"><a href="#509-Bandwidth-Limit-Exceeded" class="headerlink" title="509 Bandwidth Limit Exceeded"></a>509 Bandwidth Limit Exceeded</h4><pre><code>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。
</code></pre><h4 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h4><pre><code>获取资源所需要的策略并没有被满足。（RFC 2774）
</code></pre><h4 id="600-Unparseable-Response-Headers"><a href="#600-Unparseable-Response-Headers" class="headerlink" title="600 Unparseable Response Headers"></a>600 Unparseable Response Headers</h4><pre><code>源站没有返回响应头部，只返回实体内容
</code></pre><p>具体可以参见<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin" target="_blank" rel="noopener">HTTP状态码</a></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/11/01/python的urllib模块/" data-toggle="tooltip" data-placement="top"
                           title="python的urllib模块">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/11/01/python-之turtle工具/" data-toggle="tooltip" data-placement="top"
                           title="python 之turtle工具">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#User-agent"><span class="toc-text">User-agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Host"><span class="toc-text">Host</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Referer"><span class="toc-text">Referer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-text">Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie详解"><span class="toc-text">Cookie详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#domain选项（The-domain-option）"><span class="toc-text">domain选项（The domain option）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Path选项（The-path-option）"><span class="toc-text">Path选项（The path option）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#secure选项（The-secure-option）"><span class="toc-text">secure选项（The secure option）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用失效日期（using-expiration-dates）"><span class="toc-text">使用失效日期（using expiration dates）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subcookies"><span class="toc-text">Subcookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Status-Code"><span class="toc-text">Status Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息"><span class="toc-text">消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#100-Continue"><span class="toc-text">100 Continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#101-Switching-Protocols"><span class="toc-text">101 Switching Protocols</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#102-Processing"><span class="toc-text">102 Processing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#200-OK"><span class="toc-text">200 OK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#201-Created"><span class="toc-text">201 Created</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#202-Accepted"><span class="toc-text">202 Accepted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#203-Non-Authoritative-Information"><span class="toc-text">203 Non-Authoritative Information</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#204-No-Content"><span class="toc-text">204 No Content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#205-Reset-Content"><span class="toc-text">205 Reset Content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#206-Partial-Content"><span class="toc-text">206 Partial Content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#207-Multi-Status"><span class="toc-text">207 Multi-Status</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#300-Multiple-Choices"><span class="toc-text">300 Multiple Choices</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#301-Moved-Permanently"><span class="toc-text">301 Moved Permanently</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#302-Move-temporarily"><span class="toc-text">302 Move temporarily</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#303-See-Other"><span class="toc-text">303 See Other</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#304-Not-Modified"><span class="toc-text">304 Not Modified</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#305-Use-Proxy"><span class="toc-text">305 Use Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#306-Switch-Proxy"><span class="toc-text">306 Switch Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#307-Temporary-Redirect"><span class="toc-text">307 Temporary Redirect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求错误"><span class="toc-text">请求错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#400-Bad-Request"><span class="toc-text">400 Bad Request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#401-Unauthorized"><span class="toc-text">401 Unauthorized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#402-Payment-Required"><span class="toc-text">402 Payment Required</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#403-Forbidden"><span class="toc-text">403 Forbidden</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#404-Not-Found"><span class="toc-text">404 Not Found</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#405-Method-Not-Allowed"><span class="toc-text">405 Method Not Allowed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#406-Not-Acceptable"><span class="toc-text">406 Not Acceptable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#407-Proxy-Authentication-Required"><span class="toc-text">407 Proxy Authentication Required</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#408-Request-Timeout"><span class="toc-text">408 Request Timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#409-Conflict"><span class="toc-text">409 Conflict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#410-Gone"><span class="toc-text">410 Gone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#411-Length-Required"><span class="toc-text">411 Length Required</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#412-Precondition-Failed"><span class="toc-text">412 Precondition Failed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#413-Request-Entity-Too-Large"><span class="toc-text">413 Request Entity Too Large</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#414-Request-URI-Too-Long"><span class="toc-text">414 Request-URI Too Long</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#415-Unsupported-Media-Type"><span class="toc-text">415 Unsupported Media Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#416-Requested-Range-Not-Satisfiable"><span class="toc-text">416 Requested Range Not Satisfiable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#417-Expectation-Failed"><span class="toc-text">417 Expectation Failed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#421-too-many-connections"><span class="toc-text">421 too many connections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#422-Unprocessable-Entity"><span class="toc-text">422 Unprocessable Entity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#423-Locked"><span class="toc-text">423 Locked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#424-Failed-Dependency"><span class="toc-text">424 Failed Dependency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#425-Unordered-Collection"><span class="toc-text">425 Unordered Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#426-Upgrade-Required"><span class="toc-text">426 Upgrade Required</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#449-Retry-With"><span class="toc-text">449 Retry With</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#451Unavailable-For-Legal-Reasons"><span class="toc-text">451Unavailable For Legal Reasons</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器错误（5、6字头）"><span class="toc-text">服务器错误（5、6字头）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#500-Internal-Server-Error"><span class="toc-text">500 Internal Server Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#501-Not-Implemented"><span class="toc-text">501 Not Implemented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#502-Bad-Gateway"><span class="toc-text">502 Bad Gateway</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#503-Service-Unavailable"><span class="toc-text">503 Service Unavailable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#504-Gateway-Timeout"><span class="toc-text">504 Gateway Timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#505-HTTP-Version-Not-Supported"><span class="toc-text">505 HTTP Version Not Supported</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#506-Variant-Also-Negotiates"><span class="toc-text">506 Variant Also Negotiates</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#507-Insufficient-Storage"><span class="toc-text">507 Insufficient Storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#509-Bandwidth-Limit-Exceeded"><span class="toc-text">509 Bandwidth Limit Exceeded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#510-Not-Extended"><span class="toc-text">510 Not Extended</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#600-Unparseable-Response-Headers"><span class="toc-text">600 Unparseable Response Headers</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 风起 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://ipandasbomb.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
